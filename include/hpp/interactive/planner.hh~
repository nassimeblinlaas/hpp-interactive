// Copyright (c) 2014 CNRS
// Authors: Nassime BLIN
//
// This file is part of hpp-core
// hpp-core is free software: you can redistribute it
// and/or modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation, either version
// 3 of the License, or (at your option) any later version.
//
// hpp-core is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Lesser Public License for more details.  You should have
// received a copy of the GNU Lesser General Public License along with
// hpp-core  If not, see
// <http://www.gnu.org/licenses/>.

#ifndef HPP_CORE_INTERACTIVE_PLANNER_HH
#define HPP_CORE_INTERACTIVE_PLANNER_HH

# include <boost/tuple/tuple.hpp>
# include <hpp/core/path-planner.hh>
# include <vector>
# include <hpp/util/pointer.hh>

namespace hpp {
  namespace core {
		namespace interactive {		 
		
			/// Generic implementation of RRT algorithm
			class HPP_CORE_DLLAPI InteractivePlanner : public PathPlanner
			{
			public:
				/// Return shared pointer to new object.
				static InteractivePlannerPtr_t createWithRoadmap
		(const Problem& problem, const RoadmapPtr_t& roadmap);
				/// Return shared pointer to new object.
				static InteractivePlannerPtr_t create (const Problem& problem);
				/// One step of extension.
				virtual void oneStep ();
				/// Set configuration shooter.
				void configurationShooter (const ConfigurationShooterPtr_t& shooter);
			protected:
				/// Constructor
				InteractivePlanner (const Problem& problem, const RoadmapPtr_t& roadmap);
				/// Constructor with roadmap
				InteractivePlanner (const Problem& problem);
				/// Store weak pointer to itself
				void init (const InteractivePlannerWkPtr_t& weak);
				/// Extend a node in the direction of a configuration
				/// \param near node in the roadmap,
				/// \param target target configuration
				virtual PathPtr_t extend (const NodePtr_t& near,
					const ConfigurationPtr_t& target);
			private:
				ConfigurationShooterPtr_t configurationShooter_;
				mutable Configuration_t qProj_;
				InteractivePlannerWkPtr_t weakPtr_;
			};
		
		} // namespace interactive
  } // namespace core
} // namespace hpp
#endif // HPP_CORE_INTERACTIVE_PLANNER_HH
	



















// test pour classe templat√©e
//   namespace interactive { 
//	
//		template <typename T> class InteractivePlanner;
//	
//		template <typename T>
//		struct InteractivePlannerPtr_t
//		{
//			typedef boost::shared_ptr<InteractivePlanner<T> > type;
//		};
//
//		template<typename T>
//		class HPP_CORE_DLLAPI InteractivePlanner : public T
//		{
//    public:
//      /// Return shared pointer to new object.
//      static typename InteractivePlannerPtr_t<T>::type create 
//				(const Problem& problem);
//			/// Return shared pointer to new object.
//      static typename InteractivePlannerPtr_t<T>::type createWithRoadmap
//				(const Problem& problem, const RoadmapPtr_t& roadmap);
//      /// One step of extension.
//      virtual void oneStep ();
//      /// Set configuration shooter.
//      void configurationShooter (const ConfigurationShooterPtr_t& shooter);
//    protected:
//      // Constructor
//      InteractivePlanner (const Problem& problem, const RoadmapPtr_t& roadmap);
//			// Store weak pointer to itself
//			void init (const InteractivePlannerWkPtr_t& weak);
//    private:
//      InteractivePlannerWkPtr_t weakPtr_;
//			ConfigurationShooterPtr_t configurationShooter_;
//
////      typedef boost::tuple <NodePtr_t, ConfigurationPtr_t, PathPtr_t>
////	DelayedEdge_t;
////      typedef std::vector <DelayedEdge_t> DelayedEdges_t;
//
//    }; // class InteractivePlanner
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//			// coding inside header for template and compilation reason
//
//
//			// Constructor
//			template<typename T>
//			InteractivePlanner<T>::InteractivePlanner
//				(const Problem& problem, const RoadmapPtr_t& roadmap) :
//					PathPlanner(problem, roadmap),
//			configurationShooter_( new BasicConfigurationShooter (problem.robot()) )
//			{
//			}
//
//			template<typename T>
//			typename InteractivePlannerPtr_t<T>::type InteractivePlanner<T>::create
//				(const Problem& problem)
//			{
//				InteractivePlanner* ptr = new InteractivePlanner (problem);
//				return InteractivePlannerPtr_t<T>(ptr);;;
//			}
//
//
//	 
//	 } // namespace interactive
